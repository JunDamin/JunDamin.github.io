<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_lanyon.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=icon  href="/assets/favicon.png"> <title>Julia&#39;s Types</title> <input type=checkbox  class=sidebar-checkbox  id=sidebar-checkbox > <div class=sidebar  id=sidebar > <div class=sidebar-item > <p>A theme adapted from <a href="http://lanyon.getpoole.com/" target=_blank >Lanyon</a>.</p> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/">Home</a> <a class="sidebar-nav-item " href="/menu1/">Code blocks</a> <a class="sidebar-nav-item " href="/menu2/">More goodies</a> <a class="sidebar-nav-item " href="/menu3/">Tags</a> </nav> <div class=sidebar-item > <p>&copy; Septimia Zenobia.</p> </div> </div> <!-- Wrap is the content to shift when toggling the sidebar. We wrap the content to avoid any CSS collisions with our real content. --> <div class=wrap > <div class=masthead > <div class=container > <h3 class=masthead-title > <a href="/" title=Home >PANDA</a> <small>JD's Journey of Data Science</small> </h3> </div> </div> <div class="container content"> <div class=franklin-content ><p>There are some important type in Julia.</p> <p>To define custom vector or Matrix, you only need to define some functions for your custom type.</p> <h1 id=julias_types ><a href="#julias_types" class=header-anchor >Julia&#39;s Types</a></h1> <p>One of the Julia&#39;s key features is based on its type system. You can create and commpute with custom types without any overhead.</p> <p>How ever you need to understand the basic types of Julia to composite it.</p> <h2 id=types ><a href="#types" class=header-anchor >Types</a></h2> <p>We can think about CRUD for each types.</p> <h3 id=array ><a href="#array" class=header-anchor >Array</a></h3> <h4 id=create_an_array ><a href="#create_an_array" class=header-anchor >create an Array</a></h4> <p>how to create an array? you can just create one. with <code>&#91;&#93;</code> one thing you need to remember is one demension array is just a vector</p> <pre><code class=language-julia >array &#61; &#91;&#93;
typeof&#40;array&#41;
array &#61; &#91;1, 2, 3&#93;</code></pre><pre><code class=plaintext >3-element Vector{Int64}:
 1
 2
 3</code></pre> <h4 id=read ><a href="#read" class=header-anchor >read</a></h4> <p>read is just like the python.</p> <h4 id=update ><a href="#update" class=header-anchor >update</a></h4> <p>you can modify it with index.</p> <pre><code class=language-julia >array&#91;1&#93; &#61; 12
array</code></pre><pre><code class=plaintext >3-element Vector{Int64}:
 12
  2
  3</code></pre> <p>you also asign value with same size of vector.</p> <pre><code class=language-julia >array&#91;1:2&#93; &#61; &#91;23, 22&#93;
array</code></pre><pre><code class=plaintext >3-element Vector{Int64}:
 23
 22
  3</code></pre> <p>But one thing you need to remember, unlikely list in python, one it has its type, and then it should get certain type of input.</p> <pre><code class=language-julia >array&#91;2&#93; &#61; &quot;test&quot;</code></pre><pre><code class=plaintext >MethodError: Cannot `convert` an object of type String to an object of type Int64
Closest candidates are:
  convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6
  convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7
  convert(::Type{T}, !Matched::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250
  ...
</code></pre> <h3 id=dictionary ><a href="#dictionary" class=header-anchor >Dictionary</a></h3> <p>Dictionary is just like the one in python. But you need to use Dict&#40;&#41; not &#123;&#125;.</p> <pre><code class=language-julia >dict_A &#61; Dict&#40;&#41;
typeof&#40;dict_A&#41;

dict_A&#91;&quot;test&quot;&#93; &#61; 1
dict_A
dict_A&#91;&quot;test&quot;&#93;</code></pre><pre><code class=plaintext >1</code></pre>
<h3 id=vector ><a href="#vector" class=header-anchor >Vector</a></h3>
<h3 id=matrix ><a href="#matrix" class=header-anchor >Matrix</a></h3>
<h3 id=dataframe ><a href="#dataframe" class=header-anchor >DataFrame?</a></h3>
<h3 id=unitrange ><a href="#unitrange" class=header-anchor >UnitRange</a></h3>
<h2 id=qna ><a href="#qna" class=header-anchor >QnA</a></h2>
<h3 id=how_can_i_find_the_mathods_of_the_type ><a href="#how_can_i_find_the_mathods_of_the_type" class=header-anchor >How can I find the mathods of the type?</a></h3>
<p>You can use <code>methodswith</code> function to find methods.</p>
<pre><code class=language-julia >methodswith&#40;Matrix&#41;</code></pre><pre><code class=plaintext >[1] \(L::SuiteSparse.CHOLMOD.FactorComponent, B::Matrix{T} where T) in SuiteSparse.CHOLMOD at /opt/hostedtoolcache/julia/1.6.2/x64/share/julia/stdlib/v1.6/SuiteSparse/src/cholmod.jl:1692
[2] tr(A::Matrix{T}) where T in LinearAlgebra at /opt/hostedtoolcache/julia/1.6.2/x64/share/julia/stdlib/v1.6/LinearAlgebra/src/dense.jl:332
[3] tril(M::Matrix{T} where T, k::Integer) in LinearAlgebra at /opt/hostedtoolcache/julia/1.6.2/x64/share/julia/stdlib/v1.6/LinearAlgebra/src/dense.jl:181
[4] triu(M::Matrix{T} where T, k::Integer) in LinearAlgebra at /opt/hostedtoolcache/julia/1.6.2/x64/share/julia/stdlib/v1.6/LinearAlgebra/src/dense.jl:144
[5] similar(a::Matrix{T}) where T in Base at array.jl:354
[6] similar(a::Matrix{T}, S::Type) where T in Base at array.jl:356
[7] setindex!(A::Matrix{T} where T, x::SparseArrays.AbstractSparseMatrixCSC, I::Integer, J::AbstractVector{Bool}) in SparseArrays at /opt/hostedtoolcache/julia/1.6.2/x64/share/julia/stdlib/v1.6/SparseArrays/src/sparsematrix.jl:2923
[8] setindex!(A::Matrix{T} where T, x::SparseArrays.AbstractSparseMatrixCSC, I::AbstractVector{Bool}, J::Integer) in SparseArrays at /opt/hostedtoolcache/julia/1.6.2/x64/share/julia/stdlib/v1.6/SparseArrays/src/sparsematrix.jl:2924
[9] setindex!(A::Matrix{T} where T, x::SparseArrays.AbstractSparseMatrixCSC, I::AbstractVector{Bool}, J::AbstractVector{Bool}) in SparseArrays at /opt/hostedtoolcache/julia/1.6.2/x64/share/julia/stdlib/v1.6/SparseArrays/src/sparsematrix.jl:2925
[10] setindex!(A::Matrix{T} where T, x::SparseArrays.AbstractSparseMatrixCSC, I::AbstractVector{var"#s832"} where var"#s832"<:Integer, J::AbstractVector{Bool}) in SparseArrays at /opt/hostedtoolcache/julia/1.6.2/x64/share/julia/stdlib/v1.6/SparseArrays/src/sparsematrix.jl:2926
[11] setindex!(A::Matrix{T} where T, x::SparseArrays.AbstractSparseMatrixCSC, I::AbstractVector{Bool}, J::AbstractVector{var"#s832"} where var"#s832"<:Integer) in SparseArrays at /opt/hostedtoolcache/julia/1.6.2/x64/share/julia/stdlib/v1.6/SparseArrays/src/sparsematrix.jl:2927
[12] size(a::Matrix{T} where T) in Base at array.jl:134</code></pre>
<h3 id=how_can_i_see_the_type_hierachy ><a href="#how_can_i_see_the_type_hierachy" class=header-anchor >How can I see the type hierachy?</a></h3>
<p>You can use <code>subtypes</code> function to see subtypes.</p>
<pre><code class=language-julia >subtypes&#40;AbstractMatrix&#41;</code></pre><pre><code class=plaintext >26-element Vector{Any}:
 Base.ReinterpretArray{T, 2, S, A, IsReshaped} where {T, S, A<:(AbstractArray{S, N} where N), IsReshaped}
 Base.ReshapedArray{T, 2, P, MI} where {T, P<:AbstractArray, MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, N} where N}}
 Base.SCartesianIndices2
 BitMatrix (alias for BitArray{2})
 CartesianIndices{2, R} where R<:Tuple{OrdinalRange{Int64, Int64}, OrdinalRange{Int64, Int64}}
 Core.Compiler.BitArray{2}
 Core.Compiler.LinearIndices{2, R} where R<:Tuple{Core.Compiler.AbstractUnitRange{Int64}, Core.Compiler.AbstractUnitRange{Int64}}
 DenseMatrix{T} where T (alias for DenseArray{T, 2} where T)
 LinearAlgebra.AbstractQ
 LinearAlgebra.AbstractTriangular
 LinearAlgebra.Adjoint
 LinearAlgebra.Bidiagonal
 LinearAlgebra.Diagonal
 LinearAlgebra.Hermitian
 LinearAlgebra.LQPackedQ
 LinearAlgebra.SymTridiagonal
 LinearAlgebra.Symmetric
 LinearAlgebra.Transpose
 LinearAlgebra.Tridiagonal
 LinearAlgebra.UpperHessenberg
 LinearIndices{2, R} where R<:Tuple{AbstractUnitRange{Int64}, AbstractUnitRange{Int64}}
 PermutedDimsArray{T, 2, perm, iperm, AA} where {T, perm, iperm, AA<:AbstractArray}
 SparseArrays.AbstractSparseMatrix{Tv, Ti} where {Tv, Ti} (alias for SparseArrays.AbstractSparseArray{Tv, Ti, 2} where {Tv, Ti})
 SubArray{T, 2, P, I, L} where {T, P, I, L}
 SuiteSparse.CHOLMOD.FactorComponent
 Test.GenericArray{T, 2} where T</code></pre>
<p>You can define your custom function to display the whole type structure.</p>
<p>Also, there are some useful packages to produce type structures.</p>
<p>One of the packages is <code>AbstractTrees</code></p>
<pre><code class=language-julia >using AbstractTrees

AbstractTrees.children&#40;x::Type&#41; &#61; subtypes&#40;x&#41;
print_tree&#40;AbstractMatrix&#41;</code></pre><pre><code class=plaintext >AbstractMatrix{T} where T
├─ ReinterpretArray{T, 2, S, A, IsReshaped} where {T, S, A<:(AbstractArray{S, N} where N), IsReshaped}
├─ ReshapedArray{T, 2, P, MI} where {T, P<:AbstractArray, MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64}, N} where N}}
├─ SCartesianIndices2
├─ BitMatrix
├─ CartesianIndices{2, R} where R<:Tuple{OrdinalRange{Int64, Int64}, OrdinalRange{Int64, Int64}}
├─ BitArray{2}
├─ LinearIndices{2, R} where R<:Tuple{AbstractUnitRange{Int64}, AbstractUnitRange{Int64}}
├─ DenseMatrix{T} where T
│  ├─ Const{T, 2} where T
│  ├─ Matrix{T} where T
│  ├─ SharedMatrix{T} where T
│  └─ Dense
├─ AbstractQ
│  ├─ HessenbergQ
│  ├─ QRCompactWYQ
│  ├─ QRPackedQ
│  └─ QRSparseQ
├─ AbstractTriangular
│  ├─ LowerTriangular
│  ├─ UnitLowerTriangular
│  ├─ UnitUpperTriangular
│  └─ UpperTriangular
├─ Adjoint
├─ Bidiagonal
├─ Diagonal
├─ Hermitian
├─ LQPackedQ
├─ SymTridiagonal
├─ Symmetric
├─ Transpose
├─ Tridiagonal
├─ UpperHessenberg
├─ LinearIndices{2, R} where R<:Tuple{AbstractUnitRange{Int64}, AbstractUnitRange{Int64}}
├─ PermutedDimsArray{T, 2, perm, iperm, AA} where {T, perm, iperm, AA<:AbstractArray}
├─ AbstractSparseMatrix{Tv, Ti} where {Tv, Ti}
│  ├─ AbstractSparseMatrixCSC
│  │  └─ SparseMatrixCSC
│  └─ Sparse
├─ SubArray{T, 2, P, I, L} where {T, P, I, L}
├─ FactorComponent
└─ GenericArray{T, 2} where T
</code></pre>
<p>or you can use <code>TypeTree</code> package.</p>
<pre><code class=language-julia >using TypeTree

print&#40;join&#40;tt&#40;AbstractMatrix&#41;, &quot;&quot;&#41;&#41;</code></pre><pre><code class=plaintext >AbstractMatrix{T} where T
 ├─ Base.ReinterpretArray{T, 2, S, A, IsReshaped} where {T, S, A<:(AbstractArray{S, N} where N), IsReshaped}
 ├─ Base.ReshapedArray{T, 2, P, MI} where {T, P<:AbstractArray, MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, N} where N}}
 ├─ Base.SCartesianIndices2
 ├─ BitMatrix
 ├─ CartesianIndices{2, R} where R<:Tuple{OrdinalRange{Int64, Int64}, OrdinalRange{Int64, Int64}}
 ├─ Core.Compiler.BitArray{2}
 ├─ Core.Compiler.LinearIndices{2, R} where R<:Tuple{Core.Compiler.AbstractUnitRange{Int64}, Core.Compiler.AbstractUnitRange{Int64}}
 ├─ DenseMatrix{T} where T
 │   ├─ Base.Experimental.Const{T, 2} where T
 │   ├─ Matrix{T} where T
 │   ├─ SharedArrays.SharedMatrix{T} where T
 │   └─ SuiteSparse.CHOLMOD.Dense
 ├─ LinearAlgebra.AbstractQ
 │   ├─ LinearAlgebra.HessenbergQ
 │   ├─ LinearAlgebra.QRCompactWYQ
 │   ├─ LinearAlgebra.QRPackedQ
 │   └─ SuiteSparse.SPQR.QRSparseQ
 ├─ LinearAlgebra.AbstractTriangular
 │   ├─ LinearAlgebra.LowerTriangular
 │   ├─ LinearAlgebra.UnitLowerTriangular
 │   ├─ LinearAlgebra.UnitUpperTriangular
 │   └─ LinearAlgebra.UpperTriangular
 ├─ LinearAlgebra.Adjoint
 ├─ LinearAlgebra.Bidiagonal
 ├─ LinearAlgebra.Diagonal
 ├─ LinearAlgebra.Hermitian
 ├─ LinearAlgebra.LQPackedQ
 ├─ LinearAlgebra.SymTridiagonal
 ├─ LinearAlgebra.Symmetric
 ├─ LinearAlgebra.Transpose
 ├─ LinearAlgebra.Tridiagonal
 ├─ LinearAlgebra.UpperHessenberg
 ├─ LinearIndices{2, R} where R<:Tuple{AbstractUnitRange{Int64}, AbstractUnitRange{Int64}}
 ├─ PermutedDimsArray{T, 2, perm, iperm, AA} where {T, perm, iperm, AA<:AbstractArray}
 ├─ SparseArrays.AbstractSparseMatrix{Tv, Ti} where {Tv, Ti}
 │   ├─ SparseArrays.AbstractSparseMatrixCSC
 │   │   └─ SparseArrays.SparseMatrixCSC
 │   └─ SuiteSparse.CHOLMOD.Sparse
 ├─ SubArray{T, 2, P, I, L} where {T, P, I, L}
 ├─ SuiteSparse.CHOLMOD.FactorComponent
 └─ Test.GenericArray{T, 2} where T
</code></pre>
<p>test plots</p>
<pre><code class=language-julia >using Plots

plot&#40;1:10, 1:10&#41;</code></pre>
<img src="/assets/guides/julia_types/code/output/ISL-lab-2-mpg.svg" alt="Simple plot">

<div class=page-foot >
  <div class=copyright >
    &copy; Septimia Zenobia. Last modified: July 21, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
      </div>  
    </div> 
    
    
        <script src="/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>

    
    <label for=sidebar-checkbox  class=sidebar-toggle ></label>