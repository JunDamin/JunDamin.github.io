<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_lanyon.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=icon  href="/assets/favicon.png"> <title>Types of Julia</title> <input type=checkbox  class=sidebar-checkbox  id=sidebar-checkbox > <div class=sidebar  id=sidebar > <div class=sidebar-item > <p>A theme adapted from <a href="http://lanyon.getpoole.com/" target=_blank >Lanyon</a>.</p> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/">Home</a> <a class="sidebar-nav-item active" href="/concepts/">Concepts</a> <a class="sidebar-nav-item " href="/practices/">Practices</a> <a class="sidebar-nav-item " href="/etc/">etc</a> </nav> <div class=sidebar-item > <p>&copy; Septimia Zenobia.</p> </div> </div> <!-- Wrap is the content to shift when toggling the sidebar. We wrap the content to avoid any CSS collisions with our real content. --> <div class=wrap > <div class=masthead > <div class=container > <h3 class=masthead-title > <a href="/" title=Home >PANDA</a> <small>JD's Journey of Data Science</small> </h3> </div> </div> <div class="container content"> <div class=franklin-content ><h1 id=types_of_julia ><a href="#types_of_julia" class=header-anchor >Types of Julia</a></h1> <p>For any programming languages, data types are one of the key pillars to code programs. Therefore, to understand its data types are very important to use a language.</p> <p>Basically, Julia is a generic programming language, which simply means it can build a function without specific data type. You can write an algorithm in Julia without any type infomation on it. It may sound like it is not need to learn about data types. However, it just means that you can decide data type later. On execution stage, Julia compiler infer the proper types and find proper functions for it. It is called multiple dispatch and this design pattern, perhaps, the most important advantages of Julia.</p> <p>In Julia, you can composite your custom type and it works just like the primitive types. I think it empower users to focus on readability and logic for flexibility.</p> <p>It is also important to mention that </p> <p>There are some important type in Julia.</p> <p>To define custom vector or Matrix, you only need to define some functions for your custom type.</p> <p>One of the Julia&#39;s key features is based on its type system. You can create and commpute with custom types without any overhead.</p> <p>How ever you need to understand the basic types of Julia to composite it.</p> <h2 id=types ><a href="#types" class=header-anchor >Types</a></h2> <p>We can think about CRUD for each types.</p> <h3 id=array ><a href="#array" class=header-anchor >Array</a></h3> <h4 id=create_an_array ><a href="#create_an_array" class=header-anchor >create an Array</a></h4> <p>how to create an array? you can just create one. with <code>&#91;&#93;</code> one thing you need to remember is one demension array is just a vector</p> <pre><code class=language-julia >array &#61; &#91;&#93;
typeof&#40;array&#41;
array &#61; &#91;1, 2, 3&#93;</code></pre><pre><code class=plaintext >3-element Vector{Int64}:
 1
 2
 3</code></pre> <h4 id=read ><a href="#read" class=header-anchor >read</a></h4> <p>read is just like the python.</p> <h4 id=update ><a href="#update" class=header-anchor >update</a></h4> <p>you can modify it with index.</p> <pre><code class=language-julia >array&#91;1&#93; &#61; 12
array</code></pre><pre><code class=plaintext >3-element Vector{Int64}:
 12
  2
  3</code></pre> <p>you also asign value with same size of vector.</p> <pre><code class=language-julia >array&#91;1:2&#93; &#61; &#91;23, 22&#93;
array</code></pre><pre><code class=plaintext >3-element Vector{Int64}:
 23
 22
  3</code></pre> <p>But one thing you need to remember, unlikely list in python, one it has its type, and then it should get certain type of input.</p> <pre><code class=language-julia >array&#91;2&#93; &#61; &quot;test&quot;</code></pre><pre><code class=plaintext >MethodError: Cannot `convert` an object of type String to an object of type Int64
Closest candidates are:
  convert(::Type{T}, !Matched::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250
  convert(::Type{T}, !Matched::AbstractChar) where T<:Number at char.jl:180
  convert(::Type{T}, !Matched::CartesianIndex{1}) where T<:Number at multidimensional.jl:136
  ...
</code></pre> <h3 id=dictionary ><a href="#dictionary" class=header-anchor >Dictionary</a></h3> <p>Dictionary is just like the one in python. But you need to use Dict&#40;&#41; not &#123;&#125;.</p> <pre><code class=language-julia >dict_A &#61; Dict&#40;&#41;
typeof&#40;dict_A&#41;

dict_A&#91;&quot;test&quot;&#93; &#61; 1
dict_A
dict_A&#91;&quot;test&quot;&#93;</code></pre><pre><code class=plaintext >1</code></pre>
<h3 id=vector ><a href="#vector" class=header-anchor >Vector</a></h3>
<h3 id=matrix ><a href="#matrix" class=header-anchor >Matrix</a></h3>
<h3 id=dataframe ><a href="#dataframe" class=header-anchor >DataFrame?</a></h3>
<h3 id=unitrange ><a href="#unitrange" class=header-anchor >UnitRange</a></h3>
<h2 id=qna ><a href="#qna" class=header-anchor >QnA</a></h2>
<h3 id=how_can_i_find_the_mathods_of_the_type ><a href="#how_can_i_find_the_mathods_of_the_type" class=header-anchor >How can I find the mathods of the type?</a></h3>
<p>You can use <code>methodswith</code> function to find methods.</p>
<pre><code class=language-julia >methodswith&#40;Matrix&#41;</code></pre><pre><code class=plaintext >[1] size(a::Matrix{T} where T) in Base at array.jl:134
[2] \(L::SuiteSparse.CHOLMOD.FactorComponent, B::Matrix{T} where T) in SuiteSparse.CHOLMOD at /opt/hostedtoolcache/julia/1.6.2/x64/share/julia/stdlib/v1.6/SuiteSparse/src/cholmod.jl:1692
[3] tr(A::Matrix{T}) where T in LinearAlgebra at /opt/hostedtoolcache/julia/1.6.2/x64/share/julia/stdlib/v1.6/LinearAlgebra/src/dense.jl:332
[4] tril(M::Matrix{T} where T, k::Integer) in LinearAlgebra at /opt/hostedtoolcache/julia/1.6.2/x64/share/julia/stdlib/v1.6/LinearAlgebra/src/dense.jl:181
[5] triu(M::Matrix{T} where T, k::Integer) in LinearAlgebra at /opt/hostedtoolcache/julia/1.6.2/x64/share/julia/stdlib/v1.6/LinearAlgebra/src/dense.jl:144
[6] similar(a::Matrix{T}) where T in Base at array.jl:354
[7] similar(a::Matrix{T}, S::Type) where T in Base at array.jl:356
[8] setindex!(A::Matrix{T} where T, x::SparseArrays.AbstractSparseMatrixCSC, I::Integer, J::AbstractVector{Bool}) in SparseArrays at /opt/hostedtoolcache/julia/1.6.2/x64/share/julia/stdlib/v1.6/SparseArrays/src/sparsematrix.jl:2923
[9] setindex!(A::Matrix{T} where T, x::SparseArrays.AbstractSparseMatrixCSC, I::AbstractVector{Bool}, J::Integer) in SparseArrays at /opt/hostedtoolcache/julia/1.6.2/x64/share/julia/stdlib/v1.6/SparseArrays/src/sparsematrix.jl:2924
[10] setindex!(A::Matrix{T} where T, x::SparseArrays.AbstractSparseMatrixCSC, I::AbstractVector{Bool}, J::AbstractVector{Bool}) in SparseArrays at /opt/hostedtoolcache/julia/1.6.2/x64/share/julia/stdlib/v1.6/SparseArrays/src/sparsematrix.jl:2925
[11] setindex!(A::Matrix{T} where T, x::SparseArrays.AbstractSparseMatrixCSC, I::AbstractVector{var"#s832"} where var"#s832"<:Integer, J::AbstractVector{Bool}) in SparseArrays at /opt/hostedtoolcache/julia/1.6.2/x64/share/julia/stdlib/v1.6/SparseArrays/src/sparsematrix.jl:2926
[12] setindex!(A::Matrix{T} where T, x::SparseArrays.AbstractSparseMatrixCSC, I::AbstractVector{Bool}, J::AbstractVector{var"#s832"} where var"#s832"<:Integer) in SparseArrays at /opt/hostedtoolcache/julia/1.6.2/x64/share/julia/stdlib/v1.6/SparseArrays/src/sparsematrix.jl:2927</code></pre>
<h3 id=how_can_i_see_the_type_hierachy ><a href="#how_can_i_see_the_type_hierachy" class=header-anchor >How can I see the type hierachy?</a></h3>
<p>You can use <code>subtypes</code> function to see subtypes.</p>
<pre><code class=language-julia >subtypes&#40;AbstractMatrix&#41;</code></pre><pre><code class=plaintext >32-element Vector{Any}:
 Base.ReinterpretArray{T, 2, S, A, IsReshaped} where {T, S, A<:(AbstractArray{S, N} where N), IsReshaped}
 Base.ReshapedArray{T, 2, P, MI} where {T, P<:AbstractArray, MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, N} where N}}
 Base.SCartesianIndices2
 BitMatrix (alias for BitArray{2})
 CartesianIndices{2, R} where R<:Tuple{OrdinalRange{Int64, Int64}, OrdinalRange{Int64, Int64}}
 Core.Compiler.BitArray{2}
 Core.Compiler.LinearIndices{2, R} where R<:Tuple{Core.Compiler.AbstractUnitRange{Int64}, Core.Compiler.AbstractUnitRange{Int64}}
 DataValues.DataValueMatrix{T} where T (alias for DataValues.DataValueArray{T, 2} where T)
 DenseMatrix{T} where T (alias for DenseArray{T, 2} where T)
 GenericLinearAlgebra.EigenQ
 GenericLinearAlgebra.HermitianRFP
 GenericLinearAlgebra.HessenbergMatrix
 GenericLinearAlgebra.TriangularRFP
 LinearAlgebra.AbstractQ
 LinearAlgebra.AbstractTriangular
 LinearAlgebra.Adjoint
 LinearAlgebra.Bidiagonal
 LinearAlgebra.Diagonal
 LinearAlgebra.Hermitian
 LinearAlgebra.LQPackedQ
 LinearAlgebra.SymTridiagonal
 LinearAlgebra.Symmetric
 LinearAlgebra.Transpose
 LinearAlgebra.Tridiagonal
 LinearAlgebra.UpperHessenberg
 LinearIndices{2, R} where R<:Tuple{AbstractUnitRange{Int64}, AbstractUnitRange{Int64}}
 PermutedDimsArray{T, 2, perm, iperm, AA} where {T, perm, iperm, AA<:AbstractArray}
 SparseArrays.AbstractSparseMatrix{Tv, Ti} where {Tv, Ti} (alias for SparseArrays.AbstractSparseArray{Tv, Ti, 2} where {Tv, Ti})
 SubArray{T, 2, P, I, L} where {T, P, I, L}
 SuiteSparse.CHOLMOD.FactorComponent
 Test.GenericArray{T, 2} where T
 WeakRefStrings.StringArray{T, 2} where T</code></pre>
<p>You can define your custom function to display the whole type structure.</p>
<p>Also, there are some useful packages to produce type structures.</p>
<p>One of the packages is <code>AbstractTrees</code></p>
<pre><code class=language-julia >using AbstractTrees

AbstractTrees.children&#40;x::Type&#41; &#61; subtypes&#40;x&#41;
print_tree&#40;AbstractMatrix&#41;</code></pre><pre><code class=plaintext >AbstractMatrix{T} where T
├─ ReinterpretArray{T, 2, S, A, IsReshaped} where {T, S, A<:(AbstractArray{S, N} where N), IsReshaped}
├─ ReshapedArray{T, 2, P, MI} where {T, P<:AbstractArray, MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64}, N} where N}}
├─ SCartesianIndices2
├─ BitMatrix
├─ CartesianIndices{2, R} where R<:Tuple{OrdinalRange{Int64, Int64}, OrdinalRange{Int64, Int64}}
├─ BitArray{2}
├─ LinearIndices{2, R} where R<:Tuple{AbstractUnitRange{Int64}, AbstractUnitRange{Int64}}
├─ DataValueMatrix{T} where T
├─ DenseMatrix{T} where T
│  ├─ Const{T, 2} where T
│  ├─ Matrix{T} where T
│  ├─ SharedMatrix{T} where T
│  └─ Dense
├─ EigenQ
├─ HermitianRFP
├─ HessenbergMatrix
├─ TriangularRFP
├─ AbstractQ
│  ├─ HessenbergQ
│  ├─ QRCompactWYQ
│  ├─ QRPackedQ
│  └─ QRSparseQ
├─ AbstractTriangular
│  ├─ LowerTriangular
│  ├─ UnitLowerTriangular
│  ├─ UnitUpperTriangular
│  └─ UpperTriangular
├─ Adjoint
├─ Bidiagonal
├─ Diagonal
├─ Hermitian
├─ LQPackedQ
├─ SymTridiagonal
├─ Symmetric
├─ Transpose
├─ Tridiagonal
├─ UpperHessenberg
├─ LinearIndices{2, R} where R<:Tuple{AbstractUnitRange{Int64}, AbstractUnitRange{Int64}}
├─ PermutedDimsArray{T, 2, perm, iperm, AA} where {T, perm, iperm, AA<:AbstractArray}
├─ AbstractSparseMatrix{Tv, Ti} where {Tv, Ti}
│  ├─ AbstractSparseMatrixCSC
│  │  └─ SparseMatrixCSC
│  └─ Sparse
├─ SubArray{T, 2, P, I, L} where {T, P, I, L}
├─ FactorComponent
├─ GenericArray{T, 2} where T
└─ StringArray{T, 2} where T
</code></pre>
<p>or you can use <code>TypeTree</code> package.</p>
<pre><code class=language-julia >using TypeTree

print&#40;join&#40;tt&#40;AbstractMatrix&#41;, &quot;&quot;&#41;&#41;</code></pre><pre><code class=plaintext >AbstractMatrix{T} where T
 ├─ Base.ReinterpretArray{T, 2, S, A, IsReshaped} where {T, S, A<:(AbstractArray{S, N} where N), IsReshaped}
 ├─ Base.ReshapedArray{T, 2, P, MI} where {T, P<:AbstractArray, MI<:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, N} where N}}
 ├─ Base.SCartesianIndices2
 ├─ BitMatrix
 ├─ CartesianIndices{2, R} where R<:Tuple{OrdinalRange{Int64, Int64}, OrdinalRange{Int64, Int64}}
 ├─ Core.Compiler.BitArray{2}
 ├─ Core.Compiler.LinearIndices{2, R} where R<:Tuple{Core.Compiler.AbstractUnitRange{Int64}, Core.Compiler.AbstractUnitRange{Int64}}
 ├─ DataValues.DataValueMatrix{T} where T
 ├─ DenseMatrix{T} where T
 │   ├─ Base.Experimental.Const{T, 2} where T
 │   ├─ Matrix{T} where T
 │   ├─ SharedArrays.SharedMatrix{T} where T
 │   └─ SuiteSparse.CHOLMOD.Dense
 ├─ GenericLinearAlgebra.EigenQ
 ├─ GenericLinearAlgebra.HermitianRFP
 ├─ GenericLinearAlgebra.HessenbergMatrix
 ├─ GenericLinearAlgebra.TriangularRFP
 ├─ LinearAlgebra.AbstractQ
 │   ├─ LinearAlgebra.HessenbergQ
 │   ├─ LinearAlgebra.QRCompactWYQ
 │   ├─ LinearAlgebra.QRPackedQ
 │   └─ SuiteSparse.SPQR.QRSparseQ
 ├─ LinearAlgebra.AbstractTriangular
 │   ├─ LinearAlgebra.LowerTriangular
 │   ├─ LinearAlgebra.UnitLowerTriangular
 │   ├─ LinearAlgebra.UnitUpperTriangular
 │   └─ LinearAlgebra.UpperTriangular
 ├─ LinearAlgebra.Adjoint
 ├─ LinearAlgebra.Bidiagonal
 ├─ LinearAlgebra.Diagonal
 ├─ LinearAlgebra.Hermitian
 ├─ LinearAlgebra.LQPackedQ
 ├─ LinearAlgebra.SymTridiagonal
 ├─ LinearAlgebra.Symmetric
 ├─ LinearAlgebra.Transpose
 ├─ LinearAlgebra.Tridiagonal
 ├─ LinearAlgebra.UpperHessenberg
 ├─ LinearIndices{2, R} where R<:Tuple{AbstractUnitRange{Int64}, AbstractUnitRange{Int64}}
 ├─ PermutedDimsArray{T, 2, perm, iperm, AA} where {T, perm, iperm, AA<:AbstractArray}
 ├─ SparseArrays.AbstractSparseMatrix{Tv, Ti} where {Tv, Ti}
 │   ├─ SparseArrays.AbstractSparseMatrixCSC
 │   │   └─ SparseArrays.SparseMatrixCSC
 │   └─ SuiteSparse.CHOLMOD.Sparse
 ├─ SubArray{T, 2, P, I, L} where {T, P, I, L}
 ├─ SuiteSparse.CHOLMOD.FactorComponent
 ├─ Test.GenericArray{T, 2} where T
 └─ WeakRefStrings.StringArray{T, 2} where T
</code></pre>
<p>test plots</p>
<pre><code class=language-julia >using Plots

plot&#40;1:10, 1:10&#41;</code></pre>
<img src="/assets/concepts/julia_types/code/output/ISL-lab-2-mpg.svg" alt="Simple plot">

<div class=page-foot >
  <div class=copyright >
    &copy; Septimia Zenobia. Last modified: August 01, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
      </div>  
    </div> 
    
    
        <script src="/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>

    
    <label for=sidebar-checkbox  class=sidebar-toggle ></label>